/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
//=========================================================================
// Name & Email must be EXACTLY as in Gradescope roster!
// Name: 
// Email: 
// 
// Assignment name: 
// Lab section: 
// TA: 
// 
// I hereby certify that I have not received assistance on this assignment,
// or used code, from ANY outside source other than the instruction team
// (apart from what was provided in the starter file).
//
//=========================================================================

//=========================================================================
//
// DO NOT CHANGE ANYTHING BELOW THIS COMMENT. IT IS PROVIDED TO MAKE SURE 
// YOUR LAB IS SUCCESSFULL. 
//
//=========================================================================

`timescale 1ns / 1ps

module gen_register (clk, rst, write_en, data_in, data_out);

parameter WORD_SIZE = 32 ; 

input wire clk , rst, write_en ;
input wire [WORD_SIZE-1:0] data_in ; 
output reg [WORD_SIZE-1:0] data_out; 

always @(posedge rst or posedge clk )
begin 

	if (rst)  begin 
		data_out <= { WORD_SIZE {1'b0} };
	end 
	else if (clk) begin
	
		if ( write_en )  begin 
			data_out  <= data_in ; 
		end 		
	end 

end 

endmodule

//=========================================================================
// Name & Email must be EXACTLY as in Gradescope roster!
// Name: 
// Email: 
// 
// Assignment name: 
// Lab section: 
// TA: 
// 
// I hereby certify that I have not received assistance on this assignment,
// or used code, from ANY outside source other than the instruction team
// (apart from what was provided in the starter file).
//
//=========================================================================

//=========================================================================
//
// DO NOT CHANGE ANYTHING BELOW THIS COMMENT. IT IS PROVIDED TO MAKE SURE 
// YOUR LAB IS SUCCESSFULL. 
//
//=========================================================================

`timescale 1ns / 1ps

`define MAX_REG 32
`define WORD_SIZE 32

module cpu_registers (
    input wire clk,	
    input wire rst , 
    input wire write_en,
    input wire [4:0] src1_addr,
    input wire [4:0] src2_addr, 
    input wire [4:0] dst_addr, 
    input wire [`WORD_SIZE-1:0]data_in    ,  
    output wire [`WORD_SIZE-1:0] src1_out  ,   
    output wire [`WORD_SIZE-1:0] src2_out  
);

// -----------------------------------------------
// Memory Words and Locations  
// ----------------------------------------------- 	
reg [`WORD_SIZE-1:0] RFILE [`MAX_REG-1:0];
integer i;

// --------------------------------------
// Read statements 
// -------------------------------------- 
assign src1_out = RFILE[src1_addr] ; 
assign src2_out = RFILE[src2_addr] ; 
	
// ---------------------------------------------
// Write  
// --------------------------------------------- 
always @(posedge clk)
begin 
    if (rst) begin 
        for (i = 0; i < `MAX_REG; i = i + 1) begin
            RFILE[i] <= { `WORD_SIZE {1'b0} } ; 
        end 
    end else begin 
        if (write_en && dst_addr !== 5'b00000) begin 
            RFILE[dst_addr] <= data_in;				
        end 	
    end
end
endmodule

//=========================================================================
// Name & Email must be EXACTLY as in Gradescope roster!
// Name: 
// Email: 
// 
// Assignment name: 
// Lab section: 
// TA: 
// 
// I hereby certify that I have not received assistance on this assignment,
// or used code, from ANY outside source other than the instruction team
// (apart from what was provided in the starter file).
//
//=========================================================================

//=========================================================================
//
// DO NOT CHANGE ANYTHING BELOW THIS COMMENT. IT IS PROVIDED TO MAKE SURE 
// YOUR LAB IS SUCCESSFULL. 
//
//=========================================================================

`timescale 1ns / 1ps

`define ALU_AND  		 4'b0000
`define ALU_OR   		 4'b0001
`define ALU_ADD  		 4'b0010
`define ALU_SUBTRACT   4'b0110
`define ALU_LESS_THAN  4'b0111
`define ALU_NOR        4'b1100

`define WORD_SIZE 32 

module alu (
	input wire [3:0] alu_control,  
	input wire [`WORD_SIZE-1:0] A, 
	input wire [`WORD_SIZE-1:0] B , 
	output reg zero, 
	output reg [`WORD_SIZE-1:0] result
);

reg [`WORD_SIZE-1:0] temp ; 

// ---------------------------------------------------------
// Parameters 
// --------------------------------------------------------- 

always @(alu_control or A or B) 
begin

	case (alu_control)   // R Type Instruction 	
		`ALU_AND :       result = A & B; 
		`ALU_OR :        result = A | B; 
		`ALU_ADD :       result = A + B; 
		`ALU_SUBTRACT :  result = A - B; 
		`ALU_NOR :       result = ~(A | B) ; 
		`ALU_LESS_THAN : result = $signed(A) < $signed(B) ?  1 : 0;
		
		default : temp = { `WORD_SIZE {1'b0} } ; 
	
	endcase

	// Final results 
	zero = (result == 0) ? 1 : 0; 
end 

endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_RAMDualAccess
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input C, // Clock signal
    input ld,
    input [(AddrBits-1):0] \1A ,
    input [(AddrBits-1):0] \2A ,
    input [(Bits-1):0] \1Din ,
    input str,
    output [(Bits-1):0] \1D ,
    output [(Bits-1):0] \2D
);
    // CAUTION: uses distributed RAM
    reg [(Bits-1):0] memory [0:((1 << AddrBits)-1)];

    assign \1D = ld? memory[\1A ] : 'hz;
    assign \2D = memory[\2A ];

    always @ (posedge C) begin
        if (str)
            memory[\1A ] <= \1Din ;
    end

endmodule



module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module if_id (
  input clk,
  input en,
  input [31:0] ip_in,
  input [31:0] in_in,
  output [31:0] ip_out,
  output [31:0] in_out
);
  // incr_pc
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i0 (
    .D( ip_in ),
    .C( clk ),
    .en( en ),
    .Q( ip_out )
  );
  // instruction
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i1 (
    .D( in_in ),
    .C( clk ),
    .en( en ),
    .Q( in_out )
  );
endmodule

module id_ex (
  input clk,
  input en,
  input [1:0] WB,
  input [2:0] M,
  input [3:0] EX,
  input [31:0] ip_in,
  input [31:0] rd1_in,
  input [31:0] rd2_in,
  input [31:0] iv_in,
  input [4:0] dr1_in,
  input [4:0] dr2_in,
  output [1:0] WB_out,
  output [2:0] M_out,
  output [3:0] EX_out,
  output [31:0] ip_out,
  output [31:0] rd1_out,
  output [31:0] rd2_out,
  output [31:0] iv_out,
  output [4:0] dr1_out,
  output [4:0] dr2_out
);
  DIG_Register_BUS #(
    .Bits(2)
  )
  DIG_Register_BUS_i0 (
    .D( WB ),
    .C( clk ),
    .en( en ),
    .Q( WB_out )
  );
  DIG_Register_BUS #(
    .Bits(3)
  )
  DIG_Register_BUS_i1 (
    .D( M ),
    .C( clk ),
    .en( en ),
    .Q( M_out )
  );
  DIG_Register_BUS #(
    .Bits(4)
  )
  DIG_Register_BUS_i2 (
    .D( EX ),
    .C( clk ),
    .en( en ),
    .Q( EX_out )
  );
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i3 (
    .D( ip_in ),
    .C( clk ),
    .en( en ),
    .Q( ip_out )
  );
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i4 (
    .D( rd1_in ),
    .C( clk ),
    .en( en ),
    .Q( rd1_out )
  );
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i5 (
    .D( rd2_in ),
    .C( clk ),
    .en( en ),
    .Q( rd2_out )
  );
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i6 (
    .D( iv_in ),
    .C( clk ),
    .en( en ),
    .Q( iv_out )
  );
  DIG_Register_BUS #(
    .Bits(5)
  )
  DIG_Register_BUS_i7 (
    .D( dr1_in ),
    .C( clk ),
    .en( en ),
    .Q( dr1_out )
  );
  DIG_Register_BUS #(
    .Bits(5)
  )
  DIG_Register_BUS_i8 (
    .D( dr2_in ),
    .C( clk ),
    .en( en ),
    .Q( dr2_out )
  );
endmodule
//=========================================================================
// Name & Email must be EXACTLY as in Gradescope roster!
// Name: 
// Email: 
// 
// Assignment name: 
// Lab section: 
// TA: 
// 
// I hereby certify that I have not received assistance on this assignment,
// or used code, from ANY outside source other than the instruction team
// (apart from what was provided in the starter file).
//
//=========================================================================

//=========================================================================
//
// DO NOT CHANGE ANYTHING BELOW THIS COMMENT. IT IS PROVIDED TO MAKE SURE 
// YOUR LAB IS SUCCESSFULL. 
//
//=========================================================================

`timescale 1ns / 1ps

`define OPCODE_R_TYPE       6'b000000
`define OPCODE_LOAD_WORD    6'b100011
`define OPCODE_STORE_WORD   6'b101011
`define OPCODE_BRANCH_EQ    6'b000100
`define OPCODE_ADDI         6'b001000
 
module control_unit (
 input wire[5:0] instr_op   ,   
 output reg	 reg_dst    ,    
 output reg	 branch     ,  
 output reg  mem_read   ,   
 output reg	 mem_to_reg ,   
 output reg  [1:0]	 alu_op     ,  
 output reg  mem_write  ,    
 output reg	 alu_src    ,   
 output reg	 reg_write   );

always @(*)
begin 
	
    reg_dst     = 0;
    branch      = 0;
    mem_read    = 0;
    mem_to_reg  = 0;
    alu_op      = 0;
    mem_write   = 0;
    alu_src     = 0;
    reg_write   = 0;
	 
    case (instr_op)  

	   `OPCODE_R_TYPE :        
					
					begin 	
						reg_dst    = 1;
                  reg_write  = 1;
                  alu_op     = 2;
					end 
					
      `OPCODE_ADDI : 
						begin 
						 alu_src    = 1;
                   reg_write  = 1;
						end 
                                                
      `OPCODE_LOAD_WORD :  
						 begin 
							alu_src    = 1;
                     mem_to_reg = 1;
                     reg_write  = 1;
                     mem_read   = 1;
						 end  	
                                        
      `OPCODE_STORE_WORD :
						begin 
							alu_src    = 1;
							mem_write  = 1;
						end 
                                        
      `OPCODE_BRANCH_EQ :  
		
						begin 
							reg_dst  = 1;
							branch   = 1;
                     alu_op   = 1;
						end 	
                                        
      default :    branch = 0 ; 
        
    endcase;
	 
end 

endmodule

module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule



//=========================================================================
// Name & Email must be EXACTLY as in Gradescope roster!
// Name: 
// Email: 
// 
// Assignment name: 
// Lab section: 
// TA: 
// 
// I hereby certify that I have not received assistance on this assignment,
// or used code, from ANY outside source other than the instruction team
// (apart from what was provided in the starter file).
//
//=========================================================================

//=========================================================================
//
// DO NOT CHANGE ANYTHING BELOW THIS COMMENT. IT IS PROVIDED TO MAKE SURE 
// YOUR LAB IS SUCCESSFULL. 
//
//=========================================================================

`timescale 1ns / 1ps

`define FUNCT_AND   		6'b100100
`define FUNCT_OR    		6'b100101
`define FUNCT_ADD   		6'b100000
`define FUNCT_SUBTRACT 	6'b100010
`define FUNCT_LESS_THAN 6'b101010
`define FUNCT_NOR 		6'b100111

`define ALU_AND  		 4'b0000
`define ALU_OR   		 4'b0001
`define ALU_ADD  		 4'b0010
`define ALU_SUBTRACT   4'b0110
`define ALU_LESS_THAN  4'b0111
`define ALU_NOR        4'b1100

module alu_control (	
	input wire [1:0]	alu_op,	
	input wire [5:0]	funct,	
	output reg [3:0] 	alu_control   
);

always @(*)
begin
	if (alu_op==2'b00) begin // LW and SW 
		alu_control = `ALU_ADD ; 
 	end else if (alu_op==2'b01) begin  // Branch 
		alu_control = `ALU_SUBTRACT ; 
 	end else begin 
		case (funct)   // R Type Instruction 
			`FUNCT_AND : 		 alu_control = `ALU_AND ; 
			`FUNCT_OR  : 		 alu_control = `ALU_OR ; 
			`FUNCT_ADD : 		 alu_control = `ALU_ADD ; 
			`FUNCT_SUBTRACT  : alu_control = `ALU_SUBTRACT ; 
			`FUNCT_LESS_THAN : alu_control = `ALU_LESS_THAN ; 
			`FUNCT_NOR  : 		 alu_control = `ALU_NOR ; 
			default    :       alu_control = `ALU_ADD ;      
	endcase 
  end // End else 

end  // End block 

endmodule


module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module ex_mem (
  input [1:0] WB,
  input [2:0] M,
  input [31:0] ba_in,
  input [31:0] ar_in,
  input z_in,
  input [31:0] rd2_in,
  input [4:0] dr_in,
  input en,
  input clk,
  output [1:0] WB_out,
  output [2:0] M_out,
  output [31:0] ba_out,
  output z_out,
  output [31:0] ar_out,
  output [31:0] rd2_out,
  output [4:0] dr_out
);
  DIG_Register_BUS #(
    .Bits(2)
  )
  DIG_Register_BUS_i0 (
    .D( WB ),
    .C( clk ),
    .en( en ),
    .Q( WB_out )
  );
  DIG_Register_BUS #(
    .Bits(3)
  )
  DIG_Register_BUS_i1 (
    .D( M ),
    .C( clk ),
    .en( en ),
    .Q( M_out )
  );
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i2 (
    .D( ba_in ),
    .C( clk ),
    .en( en ),
    .Q( ba_out )
  );
  DIG_Register DIG_Register_i3 (
    .D( z_in ),
    .C( clk ),
    .en( en ),
    .Q( z_out )
  );
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i4 (
    .D( ar_in ),
    .C( clk ),
    .en( en ),
    .Q( ar_out )
  );
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i5 (
    .D( rd2_in ),
    .C( clk ),
    .en( en ),
    .Q( rd2_out )
  );
  DIG_Register_BUS #(
    .Bits(5)
  )
  DIG_Register_BUS_i6 (
    .D( dr_in ),
    .C( clk ),
    .en( en ),
    .Q( dr_out )
  );
endmodule

module mem_wb (
  input [1:0] WB,
  input [31:0] rd_in,
  input [31:0] ar_in,
  input [4:0] dr_in,
  input clk,
  input en,
  output [1:0] WB_out,
  output [31:0] rd_out,
  output [31:0] ar_out,
  output [4:0] dr_out
);
  DIG_Register_BUS #(
    .Bits(2)
  )
  DIG_Register_BUS_i0 (
    .D( WB ),
    .C( clk ),
    .en( en ),
    .Q( WB_out )
  );
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i1 (
    .D( rd_in ),
    .C( clk ),
    .en( en ),
    .Q( rd_out )
  );
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i2 (
    .D( ar_in ),
    .C( clk ),
    .en( en ),
    .Q( ar_out )
  );
  DIG_Register_BUS #(
    .Bits(5)
  )
  DIG_Register_BUS_i3 (
    .D( dr_in ),
    .C( clk ),
    .en( en ),
    .Q( dr_out )
  );
endmodule

module lab05_pipelined (
  input clk,
  input rst,
  output [31:0] PC,
  output [5:0] opcode,
  output [4:0] src1_addr,
  output [31:0] src1_out,
  output [4:0] src2_addr,
  output [31:0] src2_out,
  output [4:0] dst_addr,
  output [31:0] dst_data
);
  wire [31:0] s0;
  wire [31:0] PC_temp;
  wire [5:0] opcode_temp;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire [1:0] s7;
  wire s8;
  wire reg_write;
  wire [4:0] s9;
  wire [4:0] s10;
  wire [4:0] dst_addr_temp;
  wire [31:0] dst_data_temp;
  wire [31:0] src1_out_temp;
  wire [31:0] src2_out_temp;
  wire [31:0] instr;
  wire [4:0] s11;
  wire [15:0] s12;
  wire [31:0] s13;
  wire reg_dst;
  wire [4:0] s14;
  wire [4:0] s15;
  wire [4:0] s16;
  wire [5:0] s17;
  wire [1:0] alu_op;
  wire [3:0] s18;
  wire [31:0] s19;
  wire [31:0] s20;
  wire [31:0] s21;
  wire s22;
  wire [31:0] s23;
  wire alu_src;
  wire [31:0] s24;
  wire s25;
  wire [31:0] s26;
  wire [31:0] s27;
  wire [31:0] incrPC;
  wire PCSrc;
  wire [31:0] branchAddr;
  wire [31:0] s28;
  wire [31:0] s29;
  wire [31:0] s30;
  wire s31;
  wire mem_write;
  wire mem_read;
  wire [7:0] s32;
  wire [31:0] mem_data;
  wire [7:0] s33;
  wire [31:0] data_val;
  wire [31:0] s34;
  wire [31:0] mem_addr;
  wire [31:0] s35;
  wire [1:0] s36;
  wire [2:0] s37;
  wire [3:0] s38;
  wire [1:0] s39;
  wire [2:0] s40;
  wire [3:0] s41;
  wire [1:0] s42;
  wire [2:0] s43;
  wire [4:0] s44;
  wire [1:0] s45;
  // gen_register
  gen_register gen_register_i0 (
    .clk( clk ),
    .rst( rst ),
    .write_en( clk ),
    .data_in( s0 ),
    .data_out( PC_temp )
  );
  // cpu_registers
  cpu_registers cpu_registers_i1 (
    .clk( clk ),
    .rst( rst ),
    .write_en( reg_write ),
    .src1_addr( s9 ),
    .src2_addr( s10 ),
    .dst_addr( dst_addr_temp ),
    .data_in( dst_data_temp ),
    .src1_out( src1_out_temp ),
    .src2_out( src2_out_temp )
  );
  // alu
  alu alu_i2 (
    .alu_control( 4'b10 ),
    .A( PC_temp ),
    .B( 32'b100 ),
    .result( incrPC )
  );
  assign s33 = PC_temp[9:2];
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i3 (
    .sel( PCSrc ),
    .in_0( incrPC ),
    .in_1( branchAddr ),
    .out( s0 )
  );
  // cpumemory
  DIG_RAMDualAccess #(
    .Bits(32),
    .AddrBits(8)
  )
  DIG_RAMDualAccess_i4 (
    .str( mem_write ),
    .C( clk ),
    .ld( mem_read ),
    .\1A ( s32 ),
    .\1Din ( mem_data ),
    .\2A ( s33 ),
    .\1D ( data_val ),
    .\2D ( s34 )
  );
  // IF/ID
  if_id if_id_i5 (
    .clk( clk ),
    .en( clk ),
    .ip_in( incrPC ),
    .in_in( s34 ),
    .ip_out( s35 ),
    .in_out( instr )
  );
  // ID/EX
  id_ex id_ex_i6 (
    .clk( clk ),
    .en( clk ),
    .WB( s36 ),
    .M( s37 ),
    .EX( s38 ),
    .ip_in( s35 ),
    .rd1_in( src1_out_temp ),
    .rd2_in( src2_out_temp ),
    .iv_in( s13 ),
    .dr1_in( s10 ),
    .dr2_in( s11 ),
    .WB_out( s39 ),
    .M_out( s40 ),
    .EX_out( s41 ),
    .ip_out( s28 ),
    .rd1_out( s20 ),
    .rd2_out( s24 ),
    .iv_out( s19 ),
    .dr1_out( s14 ),
    .dr2_out( s15 )
  );
  assign s29[31:2] = s19[31:2];
  assign s29[1:0] = 2'b0;
  assign opcode_temp = instr[31:26];
  assign s9 = instr[25:21];
  assign s10 = instr[20:16];
  assign s11 = instr[15:11];
  assign s12 = instr[15:0];
  assign s17 = s19[5:0];
  assign reg_dst = s41[0];
  assign alu_op = s41[2:1];
  assign alu_src = s41[3];
  assign src1_addr = instr[25:21];
  assign src2_addr = instr[20:16];
  // control_unit
  control_unit control_unit_i7 (
    .instr_op( opcode_temp ),
    .reg_write( s1 ),
    .mem_to_reg( s2 ),
    .branch( s3 ),
    .mem_read( s4 ),
    .mem_write( s5 ),
    .reg_dst( s6 ),
    .alu_op( s7 ),
    .alu_src( s8 )
  );
  DIG_BitExtender #(
    .inputBits(16),
    .outputBits(32)
  )
  DIG_BitExtender_i8 (
    .in( s12 ),
    .out( s13 )
  );
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i9 (
    .sel( reg_dst ),
    .in_0( s14 ),
    .in_1( s15 ),
    .out( s16 )
  );
  // alu_control
  alu_control alu_control_i10 (
    .funct( s17 ),
    .alu_op( alu_op ),
    .alu_control( s18 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i11 (
    .sel( alu_src ),
    .in_0( s24 ),
    .in_1( s19 ),
    .out( s21 )
  );
  // alu
  alu alu_i12 (
    .alu_control( 4'b10 ),
    .A( s28 ),
    .B( s29 ),
    .result( s30 )
  );
  // alu
  alu alu_i13 (
    .A( s20 ),
    .B( s21 ),
    .alu_control( s18 ),
    .zero( s22 ),
    .result( s23 )
  );
  assign s36[0] = s1;
  assign s36[1] = s2;
  assign s37[0] = s3;
  assign s37[1] = s4;
  assign s37[2] = s5;
  assign s38[0] = s6;
  assign s38[2:1] = s7;
  assign s38[3] = s8;
  // EX/MEM
  ex_mem ex_mem_i14 (
    .WB( s39 ),
    .M( s40 ),
    .ba_in( s30 ),
    .ar_in( s23 ),
    .z_in( s22 ),
    .rd2_in( s24 ),
    .dr_in( s16 ),
    .en( clk ),
    .clk( clk ),
    .WB_out( s42 ),
    .M_out( s43 ),
    .ba_out( branchAddr ),
    .z_out( s31 ),
    .ar_out( mem_addr ),
    .rd2_out( mem_data ),
    .dr_out( s44 )
  );
  assign PCSrc = (s43[0] & s31);
  // MEM/WB
  mem_wb mem_wb_i15 (
    .WB( s42 ),
    .rd_in( data_val ),
    .ar_in( mem_addr ),
    .dr_in( s44 ),
    .clk( clk ),
    .en( clk ),
    .WB_out( s45 ),
    .rd_out( s27 ),
    .ar_out( s26 ),
    .dr_out( dst_addr_temp )
  );
  assign s32 = mem_addr[7:0];
  assign mem_read = s43[1];
  assign mem_write = s43[2];
  assign reg_write = s45[0];
  assign s25 = s45[1];
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i16 (
    .sel( s25 ),
    .in_0( s26 ),
    .in_1( s27 ),
    .out( dst_data_temp )
  );
  assign PC = PC_temp;
  assign opcode = opcode_temp;
  assign src1_out = src1_out_temp;
  assign src2_out = src2_out_temp;
  assign dst_addr = dst_addr_temp;
  assign dst_data = dst_data_temp;
endmodule
